# 체감 난이도

### 중

# 이유
가장 간단한 미로찾기 문제여서, 사실 어려운 난이도는 아니다.
하지만 오랜만에 풀려니 버벅였다.

C와 R모두 최대 1000이라 한 배열의 최대 크기가 1000000을 넘어서지 않는데,
모든 자리를 한번씩 돌아보는 것이 최대 계산량이므로, 시간복잡도도 O(C*R)이다.
즉, 모든 칸을 다 돌아도 1초가 되는 것은 사실상 불가능하기 때문에 편하게 문제를 풀었다.

# 회고
로직 자체는 어렵지 않았다. 많이 접해본 문제여서..

실 배열 사이즈를 오버하게 만들어서 바운더리를 설정하고
바운더리가 아닌 값은 초기값 0, 바운더리는 -1로 설정을 했다.

이 때, 어떻게 하면 파이썬처럼 가독성있게 코드를 짤 수 있을지 고민했는데
`fill` 이라는 함수가 있는 것을 알았다.
저번에 내장 함수 찾아보다가 슬쩍 보긴 했었는데, 이런 부분에 도움이 되다니..

```js
const Arr = new Array(100).fill(0);
```
이렇게 입력하면 100칸의 배열이 초기화되고, 모든 값이 0으로 채워진다.
이런 식으로 이중 리스트를 모두 0으로 채운 후에,
`forEach`를 사용해서 만약 배열의 첫줄이거나 마지막 줄이면 모든 칸을 -1로
아니면 맨 앞칸과 맨 뒷칸만 -1로 값을 변경하도록 해서 바운더리를 구현했다.

```js
const Seats = new Array(R + 2); //위 아래 바운더리 만들기 위해 R+2
for (let i = 0; i < Seats.length; i++) {
  Seats[i] = new Array(C + 2).fill(0); //모든 값을 0으로 초기화, 양 옆 바운더리 만들기 위해 C+2
}

// 바운더리 값 -1로 변경
Seats.forEach((_, i, arr) => {
  if (i === 0 || i === Seats.length - 1) {
    //모든 칸 -1로 변경
    arr[i].fill(-1);
  } else {
    //앞과 뒤를 -1로 변경
    arr[i][0] = -1;
    arr[i][arr[i].length - 1] = -1;
  }
});
```

이 방법은 앞으로도 계속 사용할 것 같다.

시간을 넉넉히 남기고 풀 수 있는 문제였는데 while의 기준을 설정하는 데에서 꼬여서 시간이 오래걸렸다.

```js
// 내가 있는 곳이 0일 때까지 반복
while (Seats[position[1]][position[0]] === 0) {
  ...
}
```
처음에는 위와 같이 코드를 구성했다. 

그랬더니, 내가 있는 자리가 0이면 무조건 다음 위치로 move하는 상황이 발생했다.

사실 이 부분까지는 위치를 원복하면 되니 큰 문제가 없는데, 위치를 원복하면, 원복한 position에 해당하는 Seat의 값이 더이상 0이 아닌게 문제였다.

고로 돌아와도 while문을 다시 들어가지 못한다는 것이었다.

이를 해결하보려고 바깥 while문(이중 while문이었다)에서 직접 **자리 원복 + 이동 경로 바꾸기 + 한칸 이동하기 + 다음 사람 부르기**
까지 해봤는 데, 코드가 점점 더러워지는 것이었다.

이 로직이 바깥까지 튀어나와있는 것은 좋지 못한 것이라는 생각이 들어 노선을 바꿨다.

```js
// 내가 갈 길이 0일 때까지 반복
while (Seats[position[1] + move[0][1]][position[0] + move[0][0]] === 0) {
  ...
}
```
두번째로 시도한 부분은 내가 가려는 길이 0이면 애초에 가지 않고(내부 while을 돌지 않고) 경로를 변경하는 것이다.

이렇게 하니 바깥 while에 이상한 로직을 덧붙일 이유도 없어지고 코드가 깔끔해졌다.

역시 일상생활에서도 우선 들어갔다가 낭패보는 경우가 많은데, 돌다리도 두드려보고 건너야겠다.
