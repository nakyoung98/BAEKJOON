# 체감 난이도

#### 중

# 이유

빙고를 어떻게 체크할 지 설계하는 부분에서, 대각선에서 세개의 경우가 나오는 걸 어떻게 체크할까 고민을 좀 했었다.

빙고 자체는 5\*5 고정에, 값을 부르는 횟수도 5\*5로 고정이기 때문에 시간 복잡도가 크게 문제가 되지는 않았다.

이후에 현재 불려진 숫자 기준 가로,세로,대각선 숫자가 0인지 체크하는 과정을 어떻게 해결할지 고민하는데 시간이 약간 걸렸다.

하지만 이중배열정도는 every로도 쉽게 만족여부 체크가 가능한 편이라 오래 걸리지는 않았다.

# 회고

생각보다 시간이 오래걸렸다.
생각 15분 + 코드 1시간 20분이 소요되었다.
아직 조건에 해당하는 값을 찾는 부분이 익숙하지 않아서 그런 듯 하다.

그래도 이번 기회에 이중 배열에서 every를 쓰는 방법을 익혔다.

### 가로 값 찾기

```JavaScript
if (Bingo[BingoRow].every((value) => value === 0)) Bingos++;
```

### 세로 값 찾기

```JavaScript
if (Bingo.every((_, r) => Bingo[r][BingoCol] === 0)) Bingos++;
```

대각선의 경우에는, 세가지 패턴이 나올 수 있는데 이 과정에서 코드가 더러워질 것 같아서 한번 머뭇거렸다.
하지만 뭘 해도 더러웠을 것 같다.

`(x,x)` / `(x,4-x)` / `(2,2)` 총 세개의 패턴이 존재할 수 있었는데,
가장 먼저 이 숫자의 위치가 `(2,2)`인지부터 확인하였다.
맞다면 우하향 대각선과 우상향 대각선을 모두 체크하도록 했다.
그다음 `(x,x)` 패턴이면 우하향 대각선,
`(x,4-x)` 패턴이면 우상향 대각선을 체크하도록 했다.
만약 위의 패턴에 속하지 않으면 가로, 세로만 체크하는 것으로 처리를 했다.
생각보다 오래걸리지는 않았다.

그리고 Bingo 줄을 찾을 때, 혹시 이전에 번호에서 **이미 Bingo가 된 줄을 또 계산해버리면** 어떡하지? 라는 생각을 했었다.
하지만 생각해보니, 그 전에 Bingo가 된 줄에 속한 번호는 다시 불릴 리가 없었다. 한마디로 걱정할 필요가 없는 모순적인 생각이었다.

시간복잡도가 정해진 문제의 경우 조금 넉넉한 편이다.
5*5 배열이었으니, `5^11` 수준의 for문만 안돌아가면 **주어진 시간(1초)안에 해결**할 수 있기 때문이다.

아직까지는 구현 문제라 크게 어렵지 않은 것 같다.
