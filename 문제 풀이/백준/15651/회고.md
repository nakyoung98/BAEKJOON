# 체감 난이도

### 중

# 이유

재귀 문제를 오랜만에 풀어서 아직 덜 감이 올라온 상태였다.
하지만 N,M 자체가 작기도 하고 한번 감을 잡으니 쉽게 풀렸다.

# 회고

처음에 30분동안 생각해도 생각이 안났다.
너무 졸려서였던 것 같은데, 자고 일어나니 바로 떠올랐다. (이래서 잠이 최고?)

중복이 가능하기 때문에 코드 구성은 매우 쉬웠다.

### 첫 코드

```js
recurse(M, []);
```

재귀함수의 첫 값으로 M과 빈 배열을 준다.

1. 종료부

```js
if (M === 0) {
  result += list.join(" ") + "\n";
  return;
}
```

만약 M이 0이면 더이상 뽑을 수 있는 카드가 없다는 뜻 (다 뽑았다는 뜻)
따라서 결과(리스트)값을 result에 문자열로 바꿔서 추가한다.  
그리고 `return`한다.

2. 진행부

```js
for (let i = 1; i <= N; i++) {
  const newList = list.slice();
  newList.push(i);
  recurse(M - 1, newList);
}
```

중복이 가능하므로 어떤 시점이라도 1부터 N까지 모든 값을 고를 수 있다.  
따라서 for문을 돌려서 1부터 N까지 새로운 값을 고른 경우의 수를 가정하고
재귀를 호출한다.

3. 재귀호출부

```js
recurse(M - 1, newList);
```

진행부에서 1~N까지 반복문을 한 것은 1부터 N중에 하나를 뽑았다라는 뜻하고 같아서 남은 뽑기 수를 M-1로 정한다.
그리고 배열에는 현재 배열을 copy하고, 뽑은 수를 push한 배열을 전달한다.

그런데 하고 나서 다른 코드를 보니, 시간이 더 짧은 것이 있었다.
내용을 보니, 굳이 새로운 배열을 추가하고 전달할 필요가 없음을 알았다.

우선 맨 처음에 배열 크기를 M만큼 설정을 해놓는다
그리고 이 배열을 가져다가 쓴다.

### 왜 그럴수 있을까?

그 이유는 배열이 result에 추가되는 시점은 M=0이 되는 시점이다.
따라서 M=0이 될 때까지 배열에 값이 추가되고, result에 값을 추가하고 나면, 이 배열안의 값은 더이상 필요가 없다.

따라서 다시 돌아가 다음 재귀를 실행할 때는, 이전에 완료된 배열은 더이상 필요가 없으니 거기 값을 바꾸던, 재사용하던 상관이 없어진다.

그래서 코드를 이렇게 간단히 쓸 수 있다.

참고로, 문제에서 수열은 사전 순으로 증가하는 순서로 출력해야한다는 조건이 있었다.  
그래서 코드가 조금 바뀌었다.  
전반적인 틀은 바뀌지 않았음!

```js
const fs = require("fs");
const rawInput = fs.readFileSync("dev/stdin").toString().split(/ /g);
const N = +rawInput.shift();
const M = +rawInput.shift();

let result = "";
const list = new Array(M);

const recurse = (m) => {
  if (m === M) {
    result += list.join(" ") + "\n";
    return;
  }

  for (let i = 1; i <= N; i++) {
    list[m] = i;
    recurse(m + 1);
  }
};

recurse(0);

console.log(result);
```
