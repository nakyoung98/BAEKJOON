# 체감 난이도

### 중

# 이유

사실 처음엔 어렵게 생각하지 않았는데,
같은 반이었던 아이들을 어떻게 기록할지(중복도 있을거고)부분에서 한번 멈췄다.
어짜피 n이 아무리 커도 1000이었기에 2초라는 넉넉한 시간에서 n^2을 해도 1000000(100만)이기 때문에
계산식에 대해 3중 for문만 안돌리면 되니 큰 걱정은 하지 않고 풀었다.

# 회고
처음 접근이 조금 막막했다.

내가 접근한 방법은
1. 1학년때 1~9반 학생을 담는 반리스트를 만든다
2. 1학년때 각 학생이 몇반이었는지 모두 탐색하여 반리스트에 추가한다

```
//이런 느낌
1반[1,3]
2반[2]
3반[6,7]
...
8반[4]
9반[5]
```
3. 학생을 또 다시 순회하면서, 1학년때 본인 반을 찾는다.  
그리고 본인반에 어떤 학생이 있었는지 가지고 온다.  
본인을 제외하고, 본인과 같은반이었던 학생을 담는 리스트에 추가한다.
```
1번 학생 -> 1학년 1반 -> 1반 학생들 [1,3] -> 1번학생에 3 추가
2번 학생 -> 1학년 2반 -> 2반 학생들 [2] -> 추가할 학생 없음
3번 학생 -> 1학년 1반 -> 1반 학생들 [1,3] -> 3번 학생에 1 추가
...

===

1번 학생 [3]
2번 학생 []
3번 학생 [1]
...

```
4. 이 행동을 5학년까지 반복한다.
5. 같은 반이었던 친구가 가장 많은 학생을 구해 **출력한다**.

#### 이 때 핵심은, 같은 반을 여러번 했던 친구라도, 친구 리스트에 한번만 추가되어야 한다는 것이다.  

  그래서 이를 해결하고자 **Set**를 썼다.  
  그렇게 하면 중복된 값은 Set에 `add` 할 때 알아서 생략해주기 때문이다.  

  나는 중복을 계산해야하므로 사실 Set의 `add` 메소드는 시간복잡도가 O(n)일 것이라 생각했다. 하지만 O(1)이라는 점이 꽤나 흥미로웠다.

  이 이유는 javascript의 Set이 해시 형태의 자료구조기 때문인데, Set이 내부적으로 각 요소의 해시값을 계산하고, 이 해시값으로 요소의 위치를 빠르게 결정할 수 있기때문이다.

  그 때 평균적인 시간 복잡도가 O(1)일 수 있는 이유는, Set 내의 해시 테이블 크기가 고정되어있기 때문이다. 여기서 해시 테이블과 함수가 효율성이 떨어지면 시간복잡도는 증가할 수 있긴 하지만..


## 겪었던 문제
바보같은 실수들을 했다.
1. 로직은 잘 짜놓고, 반복문을 1학년부터 6학년까지 돌린다던가.. (5학년까지밖에 없는데!)
2. 맨 첫줄에 학생 수가 들어오는 줄 모르고 멍청한 `split`을 했다던가..

그래도 해프닝으로 끝날 수 있었다 ^^

## 개선
생각해보니 Set을 써서 중복을 처리할 수 있다면,

